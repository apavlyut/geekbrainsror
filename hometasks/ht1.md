## 1 часть. Овтетьте на вопросы и прокомментируйте почему так происходит.

> Для выполнения задания копируете это себе через fork. В поле "ответ" указываете ответ, в поле "почему" пишете ваше понимание почему это так работает с точки зрения языка.

1) Присвойте переменной x значение 5.

```ruby
# ответ (пример):
x = 5

# почему: все так потому что присвоение в языке идет через одиночный знак равенства, порядок присвоения идет справа налево.
```

2) Какой тип данных имеет это выражение?

```ruby
"Bob"

# ответ: string
# почему: строки заключаются в одинарные или двойные ковычки
```

3) x это строка?

```ruby
x = 5
# ответ: переменная с присвоенным ей целым числом 5
# почему: вне ковычек, это целое число
```

4) Что будет результатом выполнения?

```ruby
"HEL" + "LO"
# ответ: HELLO
# почему: происходит слияние строк
```

5) Что будет результатом выполнения?

```ruby
"Hel".+("lo")
# ответ: Hello
# почему: "Hel". тоже что и "Hel", а ("lo") тоже что и "lo" в данной задаче точка и скобки лишние и не играют ни какой роли
```

6) Что будет результатом выполнения?

```ruby
"Hel" + 42
# ответ: ошибка
# почему: нельзя складывать разные типы данных
```

7) Что будет результатом выполнения?

```ruby
a = "OH"
b = "mygod"
a + b
# ответ: OHmygod
# почему: слияние строк, присвоенных переменным
```

8) Что выведет на экран?

```ruby
my_role = "Teacher"
my_role = "Student"

p my_role
# ответ: "Student"
# почему: переменной my_role присваивается новое значение, старое перезаписывается новым
```

9) Получите первую букву из строки:

```ruby
"GeekBrains"
# ответ: "GeekBrains"[0]
# почему: к сткрокам можно обрпщаться как к массивам, первый элемент массива [0]
```

10) Получите с первой по треьюю букву из строки:
```ruby
"GeekBrains"
# ответ: "GeekBrains"[2]
# почему: тоже самое что и выше достаем по номеру элемента строки
```

11) Получите последнюю букву из строки.

```ruby
"GeekBrains"
# ответ: либо "GeekBrains"[9] или что лучше "GeekBrains"[-1]
# почему: "GeekBrains"[-1] отсчет начинается с конца строки
```

12) Замените букву b на d в строке:

```ruby
"Geekbrains"
# ответ: "Geekbrains".gsub(/b/, "d")
# почему: находим букву 'b' в строке и меняем на 'd'
```

13) Присвойте значение "хеллоу" переменной howru?

```ruby
# ответ: howru = "хэллоу"
# почему: присваивание делается одним знаком "=", строка присваивается в ковычках
```

14) Что будет результатом выполнения?

```ruby
"Пьяный мастер" = never_sleeps
# ответ: ошибка
# почему: присваивание осуществляется слева на право
```

15) Что будет выведено на экран?

```ruby
chtoto = "budet"
sosvem = netak
puts sosvem
# ответ: ошибка
# почему: программа нас не понимает, чтобы вывести netak нужно добавить ковычки, сделав ее строкой
```

16) Какой будет результат?

```ruby
3 + 4
# ответ: 7
# почему: обычное сложение ruby
```

17) Какой будет результат?

```ruby
4 * 7
# ответ: 28
# почему: обычное умножение ruby
```

18) Какой будет результат?

```ruby
2 ** 3
# ответ: 8
# почему: 2 возводим в 3 степень
```

19) Какой будет результат?

```ruby
8 / 2
# ответ: 4
# почему: деление целых чисел
```

20) Какой будет результат?

```ruby
3 / 2
# ответ: 1
# почему: деление целых чисел, то что осталось после запятой округляется
```

21) Какой будет результат?

```ruby
3.0 / 2.0
# ответ: 1.5
# почему: деление чисел с плавающей запятой
```

22) Какой будет результат?

```ruby
"i am not afraid".upcase()
# ответ: "I AM NOT AFRAID"
# почему: переводим всю строку в верхний регистр
```

23) Переведите в нижний регистр.

```ruby
what = "What ArE yOuAR?"
# ответ: what.downcase
# почему: все элементы строки приводятся к нижнему регистру
```

24) Конкатенируйте строки:

```ruby
what = "Прекраная "
isthis = "годнота то"
# ответ: what + isthis
# почему: складываем строки, происходит слияние
```
25) Переведите число 5 в строку.

```ruby
# ответ: 5.to_s # => "5"
# почему: командой to_s приводим число к строе, сокращенно от to_string
```

26) Что тут за проблемы?

```ruby
my name = "Mr. Stupid"
# ответ: имя переменной не может содержать пробела
# почему: может начинаться с буквы или знака подчёркивания и состоять из латинских букв, цифр или знака подчёркивания.
```

27) Исправьте код чтобы он выполнился:

```ruby
band = "City" + 312
# ответ: band = "City" + 312.to_s   или  band = "City" + "312"
# почему: приводим оба слагаемых к одному типу данных, в данном случае это строка, поскольку строку с буквенным значением нельзя привести к числу
```

28) my_array - массив из значений "ruby" and "rails". Создайте свой массив с такими же значениями.

```ruby

# ответ: my_array = ["ruby", "rails"]
# почему: создаем массив для этого используются [] скобки, присваиваем первую строку что будет нулевым элементом массива "ruby", и вторую что будет первым элементом массива "rails"
```

29) Создайте пустой массив:

```ruby
# ответ: array = []
# почему: создаем массив не вписывая туда ни одного элемента
```

30) Создайте массив содержащий значения "алекс мерфи", 33, и 12.5.
```ruby
# ответ: array = ["алекс мерфи", 33, 12.5]
# почему: массив может хранить данные разных типов
```

31) Опишите компоненты этого выражения:

```ruby
users = ["john", "alex", "vlad"]
# ответ: массив со строчными элементами
# почему: строчные элементы обособляются ковычками, в данном случае имена пользователей
```

32) Что будет результатом выражения:

```ruby
["john", "alex", "vlad"].length()
# ответ: 3
# почему: .length() возвращает количество элементов массива
```

33) Массив корректный?

```ruby
name = "sir"
age = 32
[name, age]
# ответ: да
# почему: как мне кажется переменные ведут себя как ссылки к значениям
```

34) Получите первый элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].first
# почему: .first возвращает первый элемент массива
```

35) Получите последний элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].last
# почему: .last возвращает последний элемент массива
```

36) Добавьте строку "я молодец" в конец массива:

```ruby
["кто", "молодец", "?"]
# ответ: ["кто", "молодец", "?"].push("я молодец")
# почему: метод push вставляет строку "я молодец" в конец массива
```

37) Что будет результом выполнения?

```ruby
5 == 5
# ответ: true
# почему: знак двойного равенства - метод сравнения 5 равно 5, поэтому выводится true - правда
```

38) Что будет результом выполнения?

```ruby
true = 6
# ответ: нельзя присвоить значение true
# почему: оно зарезервированно
```

39) Продемонстрируйте что "руби" полностью эквивалентен "руби".

```ruby
# ответ: "руби" == "руби" => true
# почему: == - сравнение одинаковых строк
```

40) Что будет результом выполнения?

```ruby
4 != 4
# ответ: false
# почему: нас спрашивают неравно ли четыре четырем, это не правда и поэтому выводится ложь
```

41) Что будет результом выполнения?

```ruby
5 > 4
# ответ: true
# почему: 5 действительно больше 4, знак > тоже метод сравнения
```

42) Что будет напечатано?

```ruby
if 5 > 4
  puts "5 больше 4"
end
# ответ: "5 больше 4"
# почему: сказано если 5 > 4 (что правда - true) вывести на экран "5 больше 4"
```

43) Что будет напечатано?

```ruby
if 5 < 4
  puts "5 меньше 4"
else
  puts "5 не меньше 4"
end

# ответ: "5 не меньше 4"
# почему: выводит опять же правду (true), 5 не может быть меньше четырех это ложь(false)
```

44) Что будет напечатано?

```ruby
if "алекс" == "шмалекс"
  puts "алекс это шмалекс"
elsif "череп" == "череп"
  puts "череп и есть череп"
else
  puts "что-то пошло не так"
end
# ответ: "череп и есть череп"
# почему: первое сравнение возвращает ложь, второе правду поэтому оно и выводится, если бы и второе было ложью на экран вышло бы "что-то пошло не так"
```

45) Что будет напечатано?

```ruby
if 5
  puts "Ну привет"
end
# ответ: "Ну привет"
# почему: булево значение целочисленного объекта также оценивается как true
```

46) Что будет напечатано?

```ruby
if "ruby"
  puts "ruby это круто"
else
  puts "ruby все равно круто"
end
# ответ: "ruby это круто"
# почему: булево значение строкового объекта оценивается как true, если бы была ложь вывелось бы "ruby все равно круто"
```

47) Что будет напечатано?

```ruby
if nil
  puts "и правда nil"
else
  puts "насильно nil не будешь"
end
# ответ: "насильно nil не будешь"
# почему: булево значение nil — это false, поэтому выводится то что следует за else
```

48) Что будет напечатано?

```ruby
puts "Так тоже можно печатать логические проверки" if true
# ответ: "Так тоже можно печатать логические проверки"
# почему: выполнит код если услови истинно, а значение строкового объекта оценивается как true
```

49) Что будет напечатано?

```ruby
puts "Так тоже можно проверять если коротко" if false
# ответ: ничего
# почему: значение истинно, а условие ложно
```

50) Какое будет значение X?

```ruby
x = 5
x = x + 1
# ответ: 6
# почему: вычисление производится с права на лево, т.о. получаем x = 5 + 1
```

51) Какое будет значение helloer?

```ruby
helloer = "chill"
helloer += "hippie"
# ответ: "chillhippie"
# почему: слияние строк как в примере выше helloer = "chill"(первое присвоенное значение) + "hippie" (второе присвоенное)
```

52) Что будет напечатано?

```ruby
counter = 0
while counter < 3
  puts "Поехали кружиться"
  counter = counter + 1
end
# ответ:"Поехали кружиться"
#       "Поехали кружиться"
#       "Поехали кружиться"
# почему: цикл выполняющий вывод строки 3 раза
```

53) Что будет напечатано?

```ruby
while 3 > 15
  puts "Ну все приплыли"
end
# ответ: ничего  
# почему: условие цикла не выполнится никогда
```

54) Что будет напечатано?

```ruby
while true
  puts "Бесконечность тоже конечна, только мы об этом не всегда можем знать."
end
# ответ: бесконечно будет печатать строку
# почему: бесконечный цикл
```
