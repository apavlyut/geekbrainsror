## 1 часть. Овтетьте на вопросы и прокомментируйте почему так происходит.

> Для выполнения задания копируете это себе через fork. В поле "ответ" указываете ответ, в поле "почему" пишете ваше понимание почему это так работает с точки зрения языка.

1) Присвойте переменной x значение 5.

```ruby
# ответ (пример):
x = 5

# почему: все так потому что присвоение в языке идет через одиночный знак равенства, порядок присвоения идет справа налево.
```

2) Какой тип данных имеет это выражение?

```ruby
"Bob"

# ответ: string
# почему: т.к. значение заключено в кавычки
```

3) x это строка?

```ruby
x = 5
# ответ: нет x - целое число
# почему: т.к. при присваиваниии переменной значения неиспользуются кавычки (указывающие на то что значение - строка), а так же не используется точка для задания числа с плавающей запятой
```

4) Что будет результатом выполнения?

```ruby
"HEL" + "LO"
# ответ: HELLO
# почему: т.к. присложении двух строк получаем их слияние
```

5) Что будет результатом выполнения?

```ruby
"Hel".+("lo")
# ответ: Hello
# почему: .+ и +  разные написания одного и того же метода класса string
```

6) Что будет результатом выполнения?

```ruby
"Hel" + 42
# ответ: ошибка
# почему: сложение значений разных типов не используется
```

7) Что будет результатом выполнения?

```ruby
a = "OH"
b = "mygod"
a + b
# ответ: OHmydog
# почему: сложение двух строк
```

8) Что выведет на экран?

```ruby
my_role = "Teacher"
my_role = "Student"

p my_role
# ответ: Student
# почему: переменной присвоено новое значение
```

9) Получите первую букву из строки:

```ruby
"GeekBrains"
# ответ: "GeekBrains"[0]
# почему: если указать в квадратных скобках индекс (номер символа от начала строки), то метод вернет символ в строке с указанным индексом
```

10) Получите с первой по третью букву из строки:
```ruby
"GeekBrains"
# ответ: "GeekBrains"[0,3]
# почему: указал с какого индекса и сколько символов мне необходимо получить
```

11) Получите последнюю букву из строки.

```ruby
"GeekBrains"
# ответ: "GeekBrains"[-1]
# почему: при указании отрицательного индекса отсчет начинается с конца строки
```

12) Замените букву b на d в строке:

```ruby
"Geekbrains"
# ответ:"Geekbrains".gsub(/b/,'d')
# почему: использовал gsub, а не sub, т.к. в задании не указано, что нужно заменить только "первую встречную" b
```

13) Присвойте значение "хеллоу" переменной howru?

```ruby
# ответ: howru="хеллоу"
# почему: объявление переменной не обязательно, метод присваивания одинарный знак равно. 
```

14) Что будет результатом выполнения?

```ruby
"Пьяный мастер" = never_sleeps
# ответ: ошибка
# почему: присваивание происходит слева на право, т.е. присвоить занчению "Пьяный мастер" переменную never_sleeps не имеет смысла.
```

15) Что будет выведено на экран?

```ruby
chtoto = "budet"
sosvem = netak
puts sosvem
# ответ: ошибка 
# почему: переменная netak не определена и присвоение неопределенности не возможно
```

16) Какой будет результат?

```ruby
3 + 4
# ответ: 7
# почему: сложение двух целых чисел
```

17) Какой будет результат?

```ruby
4 * 7
# ответ: 28
# почему: перемножение целых чисел
```

18) Какой будет результат?

```ruby
2 ** 3
# ответ: 8
# почему: возведение числа 2 в степень 3
```

19) Какой будет результат?

```ruby
8 / 2
# ответ: 4
# почему: деление числа 8 на число 2
```

20) Какой будет результат?

```ruby
3 / 2
# ответ: 1
# почему: деление целого числа 3 на целое 2 (остаток отбрасывается)
```

21) Какой будет результат?

```ruby
3.0 / 2.0
# ответ: 1.5
# почему: деление числа с плавающей запятой на 2
```

22) Какой будет результат?

```ruby
"i am not afraid".upcase()
# ответ: I AM NOT AFRAID
# почему: используется метод #upcase класса string (меняет все символы в строке на заглавные)
```

23) Переведите в нижний регистр.

```ruby
what = "What ArE yOuAR?"
# ответ: what.downcase
# почему: используется метод #downcase класса string (меняет все символы в строке на строчные)
```

24) Конкатенируйте строки:

```ruby
what = "Прекраная "
isthis = "годнота то"
# ответ:what+isthis
# почему: для строк метод конкатенации соответствует символу сложения для чисел
```
25) Переведите число 5 в строку.

```ruby
# ответ: 5.to_s
# почему: для конвертирования числа в строку используется метод класса integer - #to_s
```

26) Что тут за проблемы?

```ruby
my name = "Mr. Stupid"
# ответ: my name = 'Mr. Stupid'
# почему: для уменьшения времени обработки строки кода рекомендуется ипсользовать одинарные кавычки (за исключением случаев когда необходима интерполяция строки (подстановка в строку вычисляемых значений)
```

27) Исправьте код чтобы он выполнился:

```ruby
band = "City" + 312
# ответ: band = "City" + 312.to_s
# почему: сложение значений разных типов не поддерживается и вызывает ошибку типа данных
```

28) my_array - массив из значений "ruby" and "rails". Создайте свой массив с такими же значениями.

```ruby
# ответ:   my_array = ['ruby', 'rails']
# почему: достаточно присвоить переменной необходимый массив
```

29) Создайте пустой массив:

```ruby
# ответ: myarray=[]
# почему: как бы присваивая переменной пустые квадратные строки мы даем понять, что данная переменная будет использована как массив данных  
```

30) Создайте массив содержащий значения "алекс мерфи", 33, и 12.5.
```ruby
# ответ: my_array=["алекс мерфи", 33, 12.5]
# почему: массив поумолчанию может хранить данные разных типов
```

31) Опишите компоненты этого выражения:

```ruby
users = ["john", "alex", "vlad"]
# ответ: users переменная, используемая в дальнейшем в качестве массива , = метод присваивания, [] массив, "john", "alex", "vlad" - значения массива  
# почему: при присваивании переменной массива определяется ее принадлежность к классу Array
```

32) Что будет результатом выражения:

```ruby
["john", "alex", "vlad"].length()
# ответ:3
# почему: используется метод класса Array #length - возвращает кол-во элементов массива
```

33) Массив корректный?

```ruby
name = "sir"
age = 32
[name, age]
# ответ: да
# почему: в качестве элементов массива могут выступать данные разных типов
```

34) Получите первый элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].first
# почему: есть стандартный метод #first - возвращает значение первого элемента массива
```

35) Получите последний элемент массива.

```ruby
["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].last
# почему: есть стандартный метод #last - возвращает значение последнего элемента массива
```

36) Добавьте строку "я молодец" в конец массива:

```ruby
["кто", "молодец", "?"]
# ответ: ["кто", "молодец", "?"].push("я молодец")
# почему: стандартный метод добавления элемента в конец массива #push()
```

37) Что будет результом выполнения?

```ruby
5 == 5
# ответ: true
# почему: == - метод сравнения значений 
```

38) Что будет результом выполнения?

```ruby
true = 6
# ответ: ошибка 
# почему: слово true - является зарезервированным и не может использоваться в качестве названия переменной
```

39) Продемонстрируйте что "руби" полностью эквивалентен "руби".

```ruby
# ответ: "руби"==="руби"
=> true
# почему: метод === сравнивает не только значения, но тип данных. 
```

40) Что будет результом выполнения?

```ruby
4 != 4
# ответ: false
# почему: метод != сравнивает на несовпадение и возвращает true если аргументы не равны.
```

41) Что будет результом выполнения?

```ruby
5 > 4
# ответ: true
# почему: метод > проверяет верность утверждения: левый аргумент больше правого
```

42) Что будет напечатано?

```ruby
if 5 > 4
  puts "5 больше 4"
end
# ответ: 5 больше 4
# почему: метод > проверяет верность утверждения: левый аргумент больше правого. если результат проверки условия равен true, выполняется тело управляюще конструкции 
```

43) Что будет напечатано?

```ruby
if 5 < 4
  puts "5 меньше 4"
else
  puts "5 не меньше 4"
end

# ответ: 5 не меньше 4
# почему: так как усовие вернуло false то отработала ветка else
```

44) Что будет напечатано?

```ruby
if "алекс" == "шмалекс"
  puts "алекс это шмалекс"
elsif "череп" == "череп"
  puts "череп и есть череп"
else
  puts "что-то пошло не так"
end
# ответ: череп и есть череп
# почему: задано дополнительное условие elsif, условие которого вернуло true
```

45) Что будет напечатано?

```ruby
if 5
  puts "Ну привет"
end
# ответ: Ну привет
# почему: так как для 5 определено значение (соответственно 5) то условие вернет значение true
```

46) Что будет напечатано?

```ruby
if "ruby"
  puts "ruby это круто"
else
  puts "ruby все равно круто"
end
# ответ: ruby это круто
# почему: так как для "ruby" определено значение (соответственно "ruby") то условие вернет значение true
```

47) Что будет напечатано?

```ruby
if nil
  puts "и правда nil"
else
  puts "насильно nil не будешь"
end
# ответ: насильно nil не будешь
# почему: так как nil не равно true, то отработает ветка else
```

48) Что будет напечатано?

```ruby
puts "Так тоже можно печатать логические проверки" if true
# ответ: Так тоже можно печатать логические проверки
# почему: данная запись является короткой записью управ. конструкции if. Действие выполняется если условие возвращает значение true 
```

49) Что будет напечатано?

```ruby
puts "Так тоже можно проверять если коротко" if false
# ответ: ничего
# почему: условие вернуло false
```

50) Какое будет значение X?

```ruby
x = 5
x = x + 1
# ответ: 6
# почему: перед присваиванием производится вычисление значения правой стороны выражения.
```

51) Какое будет значение helloer?

```ruby
helloer = "chill"
helloer += "hippie"
# ответ:chillhippie
# почему: это короткая запись выражения helloer=helloer+"hippie"
```

52) Что будет напечатано?

```ruby
counter = 0
while counter < 3
  puts "Поехали кружиться"
  counter = counter + 1
end
# ответ:
Поехали кружиться
Поехали кружиться
Поехали кружиться
# почему: данный цикл выполняется до тех пор пока counter меньше трех. При counter = 3 цикл не выполняется (условие - строго меньше).
```

53) Что будет напечатано?

```ruby
while 3 > 15
  puts "Ну все приплыли"
end
# ответ: ничего
# почему: данный цикл не выполнится ни разу
```

54) Что будет напечатано?

```ruby
while true
  puts "Бесконечность тоже конечна, только мы об этом не всегда можем знать."
end
# ответ: будет бесконечно выводиться:
Бесконечность тоже конечна, только мы об этом не всегда можем знать.
# почему: данный цикл выполняется бесконечно, т.к. условие всегда верно.
```
