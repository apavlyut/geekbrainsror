2) Какой тип данных имеет это выражение?

"Bob"

# ответ:  строка
# почему:  значение содержит ковычки
3) x это строка?

x = 5
# ответ:  нет, х – целое число.
# почему:    при присвоении переменной не используются ковычки
4) Что будет результатом выполнения?

"HEL" + "LO"
# ответ:   Hello
# почему:  При сложении строк происходит слияние.
5) Что будет результатом выполнения?

"Hel".+("lo")
# ответ: Hello
# почему:  точкой мы вызываем написания одного и того же метода класса string
6) Что будет результатом выполнения?

"Hel" + 42
# ответ:  Ошибка
# почему:   Сложение данных разных типов дает ошибку.
7) Что будет результатом выполнения?

a = "OH"
b = "mygod"
a + b
# ответ:  OHmygod
# почему:  Сложение двух строк
8) Что выведет на экран?

my_role = "Teacher"
my_role = "Student"

p my_role
# ответ: Student
# почему: Возвращает последнее значение переменной
9) Получите первую букву из строки:

"GeekBrains"
# ответ:  “GeekBbrains” [0]
# почему:  благодаря индексу в квадратных строчках мы возвращаем указанный символ 
10) Получите с первой по третью букву из строки:

"GeekBrains" 
# ответ: "GeekBrains"[0,3] 
# почему: указал с какого индекса и сколько символов мне необходимо получить
11) Получите последнюю букву из строки.

"GeekBrains"
# ответ: "GeekBrains"[-1]
# почему: при отрицательном индексе отсчет начинается с конца строки
12) Замените букву b на d в строке:

"Geekbrains"
# ответ:"Geekbrains".gsub(/b/,'d')
# почему: 
13) Присвойте значение "хеллоу" переменной howru?

# ответ: howru="хеллоу"
# почему:  howru – имя переменной, =   - метод присваивания,  хеллоу — значение переменной
14) Что будет результатом выполнения?

"Пьяный мастер" = never_sleeps
# ответ: ошибка 
# почему:  компьютер читает программу слева на право.
15) Что будет выведено на экран?

chtoto = "budet"
sosvem = netak
puts sosvem
# ответ: ошибка 
# почему: переменная netak не определена и присвоение неопределенности не возможно
16) Какой будет результат?

3 + 4
# ответ: 7 
# почему:   сложение 
17) Какой будет результат?

4 * 7
# ответ: 28 	
# почему: умножение
18) Какой будет результат?

2 ** 3
# ответ: 8 
# почему: возведение в степень
19) Какой будет результат?

8 / 2
# ответ: 4
# почему: деление
20) Какой будет результат?

3 / 2
# ответ: 1
# почему:  деление целого числа 
21) Какой будет результат?

3.0 / 2.0
# ответ: 1,5 
# почему: деление числа с плавающей запятой на 2
22) Какой будет результат?

"i am not afraid".upcase()
# ответ: I AM NOT AFRAID
# почему:   используется метод #upcase класса string
23) Переведите в нижний регистр.

what = "What ArE yOuAR?"
# ответ: what.downcase
# почему:  используется метод #downcase класса string
24) Конкатенируйте строки:

what = "Прекраная "
isthis = "годнота то"
# ответ: what+isthis
# почему: для строк метод конкатенации соответствует символу сложения для чисел
25) Переведите число 5 в строку.

# ответ: «5»
# почему: значение содержащееся в кавычках имеет тип данных строка («5».class)           
26) Что тут за проблемы?

my name = "Mr. Stupid"
# ответ: ошибка 
# почему: переменная пишется через нижнее подчеркивание или через my name, либо без пробела.           
27) Исправьте код чтобы он выполнился:

band = "City" + 312
# ответ: «City» + «312»
# почему:   сложение значений разных типов не поддерживается
28) my_array - массив из значений "ruby" and "rails". Создайте свой массив с такими же значениями.

band = "City" + 312
# ответ: my_array=[‘ruby’, ‘rails’]                            
# почему: надо присвоить элементу новый массив
29) Создайте пустой массив:

# ответ: [ ] || Array.new  
# почему: массив обозначается квадратными скобками, Array константа, обозначающая массив, метод .new  создает новый объект. 
30) Создайте массив содержащий значения "алекс мерфи", 33, и 12.5.

# ответ: my_array=["алекс мерфи", 33, 12.5]
# почему: массив поумолчанию может хранить данные разных типов
31) Опишите компоненты этого выражения:

users = ["john", "alex", "vlad"]
# ответ: переменная, =  -метод присваивания, [ ]  -массив,  "john", "alex", "vlad" – элементы массива строкового типа.   
# почему: 
32) Что будет результатом выражения:

["john", "alex", "vlad"].length()
# ответ: 3
# почему: lenhght – метод, который возвращает количество элементов массива.
33) Массив корректный?

name = "sir"
age = 32
[name, age]
# ответ: да
# почему: в качестве элементов массива могут выступать данные разных типов
34) Получите первый элемент массива.

["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].first
# почему: тут добавился один новый метод .first — выводит нам первый элемент массива. 
35) Получите последний элемент массива.

["john", "alex", "vlad"]
# ответ: ["john", "alex", "vlad"].last
# почему:   есть стандартный метод #last - возвращает значение последнего элемента массива
36) Добавьте строку "я молодец" в конец массива:

["кто", "молодец", "?"]
# ответ:  ["кто", "молодец", "?"].push("я молодец")
# почему:   .push и <<  это методы добавления элемента в массив  
37) Что будет результом выполнения?

5 == 5
# ответ:  true
# почему: == - метод сравнения
38) Что будет результом выполнения?

true = 6
# ответ: ошибка
# почему: нельзя присвоить значение правде
39) Продемонстрируйте что "руби" полностью эквивалентен "руби ".
# ответ: «руби==руби»
# почему: это руби
40) Что будет результом выполнения?
4 != 4
# ответ:   false
# почему: 4 есть 4
41) Что будет результом выполнения?

5 > 4
# ответ: true
# почему: 5 больше 4
42) Что будет напечатано?

if 5 > 4
  puts "5 больше 4"
end
# ответ:  5 больше 4
# почему: if запускает внутрь конструции если условие истинно
43) Что будет напечатано?

if 5 < 4
  puts "5 меньше 4"
else
  puts "5 не меньше 4"
end

# ответ: 5 не меньше 4 
# почему: так как условие вернуло false то отработала ветка else
44) Что будет напечатано?

if "алекс" == "шмалекс"
  puts "алекс это шмалекс"
elsif "череп" == "череп"
  puts "череп и есть череп"
else
  puts "что-то пошло не так"
end
# ответ:  череп и есть череп
# почему: if -ложно elsif – true 
45) Что будет напечатано?

if 5
  puts "Ну привет"
end
# ответ: Ну привет
# почему: 0 и другие не числовые значения => false      
46) Что будет напечатано?

if "ruby"
  puts "ruby это круто"
else
  puts "ruby все равно круто"
end
# ответ: ruby это круто
# почему:  
47) Что будет напечатано?

if nil
  puts "и правда nil"
else
  puts "насильно nil не будешь"
end
# ответ: насильно nil не будешь
# почему:  nil => false 
48) Что будет напечатано?

puts "Так тоже можно печатать логические проверки" if true
# ответ: Так тоже можно печатать логические проверки
# почему:  данная запись является короткой записью управ. конструкции if.
49) Что будет напечатано?

puts "Так тоже можно проверять если коротко" if false
# ответ: ничего
# почему: условие вернуло false
50) Какое будет значение X?

x = 5
x = x + 1
# ответ: 6 
# почему: Ruby возвращает последнее значение присвоенное переменной  
51) Какое будет значение helloer?

helloer = "chill"
helloer += "hippie"
# ответ: chillhippie
# почему: ± метод сложения
52) Что будет напечатано?

counter = 0
while counter < 3
  puts "Поехали кружиться"
  counter = counter + 1
end
# ответ:
# почему:
53) Что будет напечатано?

while 3 > 15
  puts "Ну все приплыли"
end
# ответ: ничего
# почему: данный цикл не выполнится ни разу
54) Что будет напечатано?

while true
  puts "Бесконечность тоже конечна, только мы об этом не всегда можем знать."
End 
# ответ: Бесконечность тоже конечна, только мы об этом не всегда можем знать.
# почему: Данный цикл выполняется вечно
